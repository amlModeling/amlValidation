import "AMLValidatorUtils.evl";



context CAEX!CAEXFile
{		
	//called multiple times from WriterHeader subitems -> therefore cached operation
	 
	constraint HasElementWriterHeader
	{
		/* In a data exchange tool chain, all participating tools shall store this information in the
		   CAEX document in the same way. Hence, the document may contain information about
		   multiple tools of a data exchange tool chain.A tool may remove the writer information of
		   other tools. This may hinder the iterative data exchange with the other tools: hence the
		   removal of writer information of other tools is not recommended.
		   • This information shall be stored as part of the CAEX AdditionalInformation of the root
		   object of the CAEX document.
	       • The AdditionalInfomation block shall be named “WriterHeader”.
		*/
		
		guard: self.satisfies("HasElementAdditionalInformation")
		
		check: self.additionalInformation.hasGenericElement("WriterHeader")
				
		message : self.filename + ": No Element <WriterHeader> defined"
	}	
	
	constraint HasWriterName
	{
		/* Meta information "WriterName" mandatory */		
		guard: self.satisfies("HasElementWriterHeader")
		
		check: self.additionalInformation.hasGenericElement("WriterName")
		
		message: self.filename + ": No Element <WriterName> defined"	
	}
	
	constraint HasWriterID
	{
		/* Meta information "WriterID" mandatory */
		guard: self.satisfies("HasElementWriterHeader")
		
		check: self.additionalInformation.hasGenericElement("WriterID")
		
		message: self.filename + ": No Element <WriterID> defined"
	
	}
	
	constraint HasVendor
	{
		/* Meta information "WriterVendor" mandatory */	
		guard: self.satisfies("HasElementWriterHeader")
		
		check: self.additionalInformation.hasGenericElement("WriterVendor")
		
		message: self.filename + ": No Element <WriterVendor> defined"
	
	}
	
	constraint HasVendorURL
	{
		/* Meta information "WriterVendorURL" mandatory */	
		guard: self.satisfies("HasElementWriterHeader")
		
		check: self.additionalInformation.hasGenericElement("WriterVendorURL")
		
		message: self.filename + ": No Element <WriterVendorURL> defined"
	
	}
	
	constraint HasVersion
	{
		/* Meta information "WriterVersion" mandatory */	
		guard: self.satisfies("HasElementWriterHeader")
		
		check: self.additionalInformation.hasGenericElement("WriterVersion")
		
		message: self.filename + ": No Element <WriterVersion> defined"
	
	}
	
	constraint HasWriterRelease
	{
		/* Meta information "WriterRelease" mandatory */	
		guard: self.satisfies("HasElementWriterHeader")
		
		check: self.additionalInformation.hasGenericElement("WriterRelease")
		
		message: self.filename + ": No Element <WriterRelease> defined"
	
	}
	
	constraint HasLastWritingDateTime
	{
		/* Meta information "LastWritingDateTime" mandatory */	
		guard: self.satisfies("HasElementWriterHeader")
		
		check: self.additionalInformation.hasGenericElement("LastWritingDateTime")
		
		message: self.filename + ": No Element <LastWritingDateTime> defined"
	
	}
	
	constraint IsLastWritingDateTimeCorrectFormated
	{
		/* Meta information "LastWritingDateTime" has to be of type DateTime 
		   ATTENTION - only rough format checking - invalid dates 2016-99-99 are not checked */	
		guard: self.satisfies("HasLastWritingDateTime")
		
		check
		{
			var lastWritingDate = self.additionalInformation.getGenericElement("LastWritingDateTime").value;
			
			return lastWritingDate.matches("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}).*");			
		}
		
		message: self.filename + ": LastWritingDateTime '" + lastWritingDate + "' is not of type DateTime"	
	}
	
	
	constraint NoDuplicatedMetaInformationInWriterHeader
	{
		/* Multiple meta information of the same name are forbidden in the same “WriterHeader” element. */	
		guard: self.satisfies("HasElementWriterHeader")
		
		check
		{
			var writerHeader = self.additionalInformation.getGenericElement("WriterHeader");			
			var duplicates = writerHeader.getAllChildNodeNames().getDuplicates();
			
			return duplicates.isEmpty();						
		}
		
		message: self.filename + ": LastWritingDateTime '" + lastWritingDate + "' is not of type DateTime"	
	}
	
	
	
	
}


